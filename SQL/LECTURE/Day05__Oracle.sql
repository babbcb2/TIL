
-- DDL (CREATE, DROP, ALTER)
-- 1. 테이블생성 (제약조건)
-- 2. 제약조건
--  NOT NULL - 컬럼레벨의 제약만 가능
--  UNIQUE
--  PRIMARY KEY : NOT NULL 과 UNIQUE 결합한
--  FOREIGEN KEY
--  CHECK
-- 2-1. 제약조건을 설정하는 방법 : 테이블 레벨, 컬럼 레벨


CREATE TABLE TABLE_NAME(
    COLUMN_NAME DATETYPE [DEFAULT EXPR][CONSTRINT],
    COLUMN_NAME DATETYPE [DEFAULT EXPR][CONSTRINT],
    COLUMN_NAME DATETYPE [DEFAULT EXPR][CONSTRINT],
    COLUMN_NAME DATETYPE [DEFAULT EXPR][CONSTRINT],
    TABLE_CONSTRAINT
)

DROP TABLE TEST_MEMBER ;

CREATE TABLE TEST_MEMBER(
    ID  VARCHAR2(50),
    PWD VARCHAR2(50),
    ADDR    VARCHAR2(50) DEFAULT 'SEOUL',
    PRIMARY KEY (ID,PWD)
)

INSERT INTO TEST_MEMBER(ID, PWD, ADDR) VALUES('JSLIM', 'JSLIM','SEOUL');
INSERT INTO TEST_MEMBER VALUES('jisl', 'JSLIM', NULL);
INSERT INTO TEST_MEMBER (ID,PWD) VALUES('ADMIN','JSLIM');

SELECT *
FROM    TEST_MEMBER;


-- FK (부모에 의존하는 데이터이거나 NULL값을 허용)
CREATE TABLE TEST_FK(
    ID      CHAR(3) PRIMARY KEY,
    NAME    VARCHAR(50) NOT NULL,
    LID     CHAR(2),
    FOREIGN KEY(LID) REFERENCES LOCATION (LOCATION_ID)
)

SELECT  LOC_DESCRIBE, ID
FROM    LOCATION
RIGHT JOIN    TEST_FK ON(LOCATION_ID = LID) ;


INSERT INTO TEST_FK VALUES('C', 'JSLIM', NULL)
INSERT INTO TEST_FK VALUES('A', 'JSLIM', 'OT')
INSERT INTO TEST_FK VALUES('B', 'JSLIM', 'A1')

SELECT *
FROM    TEST_FK;

SELECT *
FROM    LOCATION;

DROP TABLE TEST_FK ;


-- INSERT 구문
-- INSERT INTO TABLE_NAME ([컬럼리스트]) VALUES(VALUE, VALUE) ;


SELECT  *
FROM    LOCATION ;

CREATE  TABLE TEST_COMPOSIT_PK(
    ID      VARCHAR2(50),
    NAME    VARCHAR2(50),
    SALARY  NUMBER CHECK (SALARY > 0),
    GENDER  CHAR(1) CHECK (GENDER IN ('M','F')),
    PRIMARY KEY (ID,NAME)
)

INSERT INTO TEST_COMPOSIT_PK VALUES('JSLIM','임정섭',100,'M')

SELECT *
FROM    TEST_COMPOSIT_PK

DROP TABLE TEST_COMPOSIT_FK ;

CREATE   TABLE TEST_COMPOSIT_FK(
    PID VARCHAR2(50) PRIMARY KEY,
    ID  VARCHAR2(50),
    NAME VARCHAR2(50),
    FOREIGN KEY (ID,NAME) REFERENCES TEST_COMPOSIT_PK (ID, NAME),
    PRIMARY KEY (PID, ID, NAME)
)

INSERT INTO TEST_COMPOSIT_FK VALUES('P001', 'JSLIM', '임정섭')
SELECT *
FROM    TEST_COMPOSIT_FK

CREATE  TABLE TEST_S1(
    SID     VARCHAR2(50) PRIMARY KEY,
    PHONE   VARCHAR2(50)
)

CREATE  TABLE TEST_S2(
    TID     VARCHAR2(50) PRIMARY KEY,
    NAME    VARCHAR2(50) DEFAULT 'DEFAULT'
)

CREATE  TABLE TEST_CHILD(
    CID     VARCHAR2(50) PRIMARY KEY,
    SID     VARCHAR2(50) REFERENCES TEST_S1(SID),
    TID     VARCHAR2(50) REFERENCES TEST_S2(TID)
)

INSERT INTO TEST_S1 VALUES('CHY',01054750286)
INSERT INTO TEST_S2 VALUES('BABBCB','DEFAULT')
INSERT INTO TEST_CHILD VALUES ('YOO','CHY','BABBCB')

SELECT *
FROM    TEST_S1;

SELECT *
FROM    TEST_S2;

SELECT *
FROM    TEST_CHILD;


DROP TABLE TEST_S1
DROP TABLE TEST_S2
DROP TABLE TEST_CHILD


-- VIEW
-- CREATE OR REPLACE

CREATE OR REPLACE VIEW VIEW_NAME(ALIAS)
AS SUBQUERY;


CREATE OR REPLACE VIEW V_EMP (NAME,DEPT)
AS  SELECT  EMP_NAME, DEPT_ID
    FROM    EMPLOYEE
    WHERE   DEPT_ID = '90';
    
SELECT *
FROM    V_EMP;

-- 직급이 '사원'인 직원의 이름, 부서이름, 직급을 갖는 V_EMP_DEPT_JOB 뷰를 작성하시오

DROP VIEW V_EMP_DEPT_JOB

CREATE OR REPLACE VIEW V_EMP_DEPT_JOB ("이름","부서이람","직급")
AS  SELECT  EMP_NAME, DEPT_NAME, JOB_TITLE
    FROM    EMPLOYEE
    JOIN    JOB          USING(JOB_ID)
    JOIN    DEPARTMENT  USING(DEPT_ID)
    WHERE   JOB_TITLE =  '사원' ;

SELECT  *
FROM    V_EMP_DEPT_JOB


-- SEQUENCE 객체
-- CREATE SEQUENCE SEQUENCE_NAME ;
-- NEXTVAL, CURRVAL


DROP SEQUENCE TEST_SEQ;

CREATE SEQUENCE TEST_SEQ
START WITH      300
INCREMENT BY    2
MAXVALUE        310
NOCYCLE
NOCACHE ;

SELECT TEST_SEQ.NEXTVAL FROM DUAL ;

SELECT TEST_SEQ.CURRVAL FROM DUAL ;


-- 18문제
-- TOP-N 분석 : 조건에 맞는 최상위 레코드 N개를 식별해야하는 경우 사용하는 쿼리기법
-- 원리 1.정렬 2.ROWNUM 3.부여된 순번대로 필요한 만큼 식별
-- 평균급여는 정수 3자리에서 올림한다
-- 부서별 평균급여보다 많은 급여를 받는 사원의 정보 중 사원 이름, 급여를 조회하려고 합니다.
-- FROM SUBQUERY(INLINE VIEW)를 이용해서 작성해 보시죠
 -- ROWNUM 최상위 한건만 가져옴
SELECT ROWNUM, EMP_NAME, SALARY
FROM    (SELECT  EMP_NAME, SALARY     
         FROM    (SELECT  DEPT_ID, ROUND(AVG(SALARY), -3) AS DAVG
                  FROM    EMPLOYEE
                  GROUP BY    DEPT_ID ) INVIEW
                  JOIN    EMPLOYEE E ON(E.DEPT_ID = INVIEW.DEPT_ID)
                  WHERE   SALARY > INVIEW.DAVG
                  ORDER BY 2 DESC)
WHERE   ROWNUM <= 5 ;

SELECT  *
FROM    (SELECT EMP_NAME, SALARY,
                RANK() OVER(ORDER BY SALARY DESC) AS R
         FROM   EMPLOYEE)
WHERE   R <= 5 ;

-- DML (INSERT, UPDATE, DELECT)
-- UPDATE 구문 (수정)
UPDATE  TABLE_NAME
SET     [COLUM_NAME = VALUE,]
WHERE   CONDITION ;

-- DROP = 테이블 삭제

DELETE
FROM    TABLE_NAME
WHERE   CONDITION ;

CREATE TABLE TEST_DML(
    ID      VARCHAR2(50) PRIMARY KEY,
    PWD     VARCHAR2(50) NOT NULL,
    NAME    VARCHAR2(50) NOT NULL,
    SALARY  NUMBER      CHECK (SALARY > 0),
    MARRIAGE CHAR(1)    CHECK ( MARRIAGE IN ('Y','N'))
)

INSERT INTO TEST_DML VALUES('JSLIM', 'JSLIM', '임정섭', 100, 'Y')
INSERT INTO TEST_DML VALUES('CHYOO', 'SSS', '유창호', 100, 'N')

UPDATE  TEST_DML
SET     MARRIAGE = 'N'
WHERE   ID = 'JSLIM'

DELETE
FROM    TEST_DML
WHERE   ID = 'JSLIM'

SELECT *
FROM    TEST_DML